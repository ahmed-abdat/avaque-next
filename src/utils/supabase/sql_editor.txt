-- Enable the necessary extensions
create extension if not exists "uuid-ossp";

-- Create custom types
create type user_role as enum ('admin', 'consultant', 'student');

-- Create profiles table (extends auth.users)
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade primary key,
  role user_role not null default 'student',
  full_name text,
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create consultant_profiles table
create table if not exists public.consultant_profiles (
  id uuid references auth.users on delete cascade primary key,
  specialization text not null,
  bio_ar text,
  bio_fr text,
  hourly_rate numeric(10,2) not null,
  is_approved boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create bookings table
create table if not exists public.bookings (
  id uuid default uuid_generate_v4() primary key,
  student_id uuid references auth.users(id) on delete cascade not null,
  consultant_id uuid references consultant_profiles(id) on delete cascade not null,
  status text not null default 'pending',
  scheduled_time timestamp with time zone not null,
  duration_minutes integer not null default 60,
  total_amount numeric(10,2) not null,
  google_meet_link text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  constraint valid_status check (status in ('pending', 'payment_pending', 'confirmed', 'completed', 'cancelled'))
);

-- Create payments table
create table if not exists public.payments (
  id uuid default uuid_generate_v4() primary key,
  booking_id uuid references public.bookings(id) on delete cascade not null,
  amount numeric(10,2) not null,
  payment_proof_url text,
  status text not null default 'pending',
  confirmed_by uuid references auth.users(id),
  confirmed_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  constraint valid_status check (status in ('pending', 'confirmed', 'rejected'))
);

-- Create reviews table
create table if not exists public.reviews (
  id uuid default uuid_generate_v4() primary key,
  booking_id uuid references public.bookings(id) on delete cascade not null,
  student_id uuid references auth.users(id) on delete cascade not null,
  consultant_id uuid references consultant_profiles(id) on delete cascade not null,
  rating integer not null,
  comment text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
  constraint valid_rating check (rating >= 1 and rating <= 5),
  constraint one_review_per_booking unique (booking_id)
);

-- Set up Row Level Security (RLS)
alter table public.profiles enable row level security;
alter table public.consultant_profiles enable row level security;
alter table public.bookings enable row level security;
alter table public.payments enable row level security;
alter table public.reviews enable row level security;

-- Create policies
-- Profiles: viewable by everyone, but only updatable by the owner or admin
create policy "Profiles are viewable by everyone"
  on public.profiles for select
  using (true);

create policy "Users can update their own profile"
  on public.profiles for update
  using (auth.uid() = id);

-- Consultant profiles: viewable by everyone, but only updatable by the owner or admin
create policy "Consultant profiles are viewable by everyone"
  on public.consultant_profiles for select
  using (true);

create policy "Consultants can update their own profile"
  on public.consultant_profiles for update
  using (auth.uid() = id);

-- Bookings: viewable by participants and admin
create policy "Users can view their own bookings"
  on public.bookings for select
  using (
    auth.uid() = student_id or 
    auth.uid() = consultant_id or
    exists (
      select 1 from public.profiles
      where id = auth.uid() and role = 'admin'
    )
  );

-- Payments: viewable by booking participants and admin
create policy "Users can view their own payments"
  on public.payments for select
  using (
    exists (
      select 1 from public.bookings
      where bookings.id = payments.booking_id
      and (
        bookings.student_id = auth.uid() or
        bookings.consultant_id = auth.uid() or
        exists (
          select 1 from public.profiles
          where id = auth.uid() and role = 'admin'
        )
      )
    )
  );

-- Reviews: viewable by everyone, but only creatable by the student who booked
create policy "Reviews are viewable by everyone"
  on public.reviews for select
  using (true);

create policy "Students can create reviews for their bookings"
  on public.reviews for insert
  with check (
    auth.uid() = student_id and
    exists (
      select 1 from public.bookings
      where bookings.id = reviews.booking_id
      and bookings.student_id = auth.uid()
      and bookings.status = 'completed'
    )
  );

-- Create functions
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, role, full_name)
  values (new.id, 'student', new.raw_user_meta_data->>'full_name');
  return new;
end;
$$ language plpgsql security definer;

-- Set up triggers
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user(); 